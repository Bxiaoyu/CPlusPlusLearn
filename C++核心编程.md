# C++核心编程

本阶段主要针对C++`面向对象`编程技术做记录

## 1.内存分区模型

C++程序在执行时，将内存大方向划分为`4个区域`

* **代码区：**存放函数体的二进制代码，由操作系统进行管理
* **全局区：**存放`全局变量，静态变量，常量`
* **栈区：**由编译器自动分配与释放，存放`函数的参数值，局部变量等`
* **堆区：**由程序员分配和释放，若不主动释放，程序结束时由操作系统回收，但是程序运行可能出现意想不到的问题



**内存四区意义：**

不同区域存放的数据被赋予不同的生命周期，编程更灵活，但对于程序员的要求也比较高。

### 1.1 程序运行前

在代码编译后，生成了exe可执行程序，`未执行该程序前`分为两个区域：

**代码区：**

* 存放CPU执行的机器指令
* 代码区是`共享`的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可
* 代码区是`只读`的，使其只读的原因是防止程序意外地修改了它的指令

**全局区：**

* `全局变量和静态变量`存放于此

* 全局区还包含了`常量区`，`字符串常量和其它常量`也存放于此

* `该区域的数据在程序结束后由操作系统释放`

  ![图一](./images/mem_global.png)



示例：

```c++
// 全局变量
int g_a = 10;
int g_b = 10;

// 全局常量
const int c_g_a = 10;
const int c_g_b = 10;

int main()
{
	// 局部变量
	int l_a = 10;
	int l_b = 10;
	cout << "局部变量 l_a 的地址为：" << &l_a << endl;
	cout << "局部变量 l_b 的地址为：" << &l_b << endl;

    // 全局变量
	cout << "全局变量 g_a 的地址为：" << &g_a << endl;
	cout << "全局变量 g_b 的地址为：" << &g_b << endl;

	// 静态变量
	static int s_a = 10;
	static int s_b = 10;
	cout << "静态变量 s_a 的地址为：" << &s_a << endl;
	cout << "静态变量 s_b 的地址为：" << &s_b << endl;


	/*
		常量：
			1.字符串常量
			2.const 修饰的变量：
				2.1 const 修饰的局部变量
				2.2 const 修饰的全部变量
	*/
	cout << "字符串常量的地址为：" << &"hello world" << endl;
	
	// const 修饰的全局变量
	cout << "全局常量 c_g_a 的地址为：" << &c_g_a << endl;
	cout << "全局常量 c_g_b 的地址为：" << &c_g_b << endl;

	// const 修饰的局部变量
	const int c_l_a = 10;
	const int c_l_b = 10;

	cout << "局部常量 c_l_a 的地址为：" << &c_l_a << endl;
	cout << "局部常量 c_l_b 的地址为：" << &c_l_b << endl;
	return 0;
}

结果：
局部变量 l_a 的地址为：00EFFDD8
局部变量 l_b 的地址为：00EFFDCC
全局变量 g_a 的地址为：00B9C000
全局变量 g_b 的地址为：00B9C004
静态变量 s_a 的地址为：00B9C008
静态变量 s_b 的地址为：00B9C00C
字符串常量的地址为：00B99C00
全局常量 c_g_a 的地址为：00B99B30
全局常量 c_g_b 的地址为：00B99B34
局部常量 c_l_a 的地址为：00EFFDC0
局部常量 c_l_b 的地址为：00EFFDB4
```

**总结：**

* C++程序在运行前分为全局区和代码区
* 代码区特点是共享和只读
* 全局区存放全局变量，静态变量，常量
* 常量区中存放`const修饰的全局常量和字符串常量`

### 1.2 程序运行后

#### 1.2.1 栈区

**栈区：**

* 由编译器自动分配和释放，存放函数的参数值，局部变量等
* 注意事项：`不要返回局部变量的地址`，栈区开辟的数据由编译器自动释放



示例：

```c++
// 测试返回局部变量地址（开发中禁止这么做）
int* func()
{
	int a = 10;  // 局部变量存放在栈区，栈区的数据在函数执行完成后自定释放
	return &a;   // 返回局部变量的地址
}

int main()
{
	// 接收func函数返回值
	int *p = func();

	cout << "*p = " << *p << endl; // 第一次可以打印正确值，是因为编译器做了保留
	cout << "*p = " << *p << endl; // 第二次这个数字就不保留了
	return 0;
}

结果：
*p = 10
*p = 2050276320
```

#### 1.2.2 堆区

**堆区：**

* 由程序员分配释放，若不主动释放，程序结束时由操作系统回收
* 在C++中主要利用关键字 `new` 在堆区开辟内存



示例：

```c++
// 在堆区分配内存，返回堆区数据地址
int* func2()
{
	// 利用new关键字，可以将数据开辟到堆区
	// 指针 本质也是局部变量，放在栈区，指针保存的数据是放在堆区
	int *p = new int(10);
	return p;
}

int main()
{
	// 接收func2函数返回值
	int *p1 = func2();
	
	cout << "*p1 = " << *p1 << endl;
	cout << "*p1 = " << *p1 << endl;
    
    delete p1;
	return 0;
}

结果：
*p1 = 10
*p1 = 10
```

**总结：**

* 堆区数据由程序员开辟和释放
* 堆区数据利用new关键字开辟内存

### 1.3 new 操作符

C++中利用 `new` 操作符在堆区开辟数据

堆区开辟的数据由程序员手动开辟，手动释放，利用 `delete` 操作符释放

语法：`new` 数据类型

利用 new 创建的时候，会返回该数据对应类型的指针



```c++
int main()
{
    // 基本语法
    int *p = new int(10);
    cout << *p << endl;
    
    // 开辟数组
    int *arr = new int[10];
    for(int i = 0; i < 10; i++)
    {
        arr[i] = i + 10;
    }
    for(int i = 0; i < 10; i++)
    {
        cout << arr[i] << endl;
    }
    
    // 利用delete释放堆区数据
    delete p;
    // 释放数组 delete[] 数组名
    delete[] arr;
    
    return 0;
}
```

## 2.引用

